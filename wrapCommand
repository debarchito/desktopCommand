#!/usr/bin/env python3
"""
Runs a command inside a pseudo-terminal with a fixed size and timeout, then
converts its ANSI output to HTML.
"""
import argparse
import fcntl
import os
import pty
import re
import select
import signal
import struct
import subprocess
import termios
import time
import sys
from typing import List, Dict, Any

def create_state() -> Dict[str, Any]:
    return {
        "row": 0,
        "col": 0,
        "lines": [[]],
        "fg": None,
        "bg": None,
        "bold": False,
        "ignoreClearsAfterAltExit": False,
        "savedRow": 0,
        "savedCol": 0,
    }


def escape_html(text: str) -> str:
    return (
        text.replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace('"', "&quot;")
    )


def ansi256_to_hex(code: str):
    try:
        c = int(code, 10)
    except ValueError:
        return None
    if c < 16:
        base = [
            "#000000",
            "#800000",
            "#008000",
            "#808000",
            "#000080",
            "#800080",
            "#008080",
            "#c0c0c0",
            "#808080",
            "#ff0000",
            "#00ff00",
            "#ffff00",
            "#0000ff",
            "#ff00ff",
            "#00ffff",
            "#ffffff",
        ]
        return base[c]
    if 16 <= c <= 231:
        idx = c - 16
        r = idx // 36
        g = (idx % 36) // 6
        b = idx % 6
        values = [r, g, b]
        comps = [0 if n == 0 else 55 + n * 40 for n in values]
        return "#" + "".join(f"{v:02x}" for v in comps)
    if 232 <= c <= 255:
        level = 8 + (c - 232) * 10
        return f"#{level:02x}{level:02x}{level:02x}"
    return None


def basic_color(code: str):
    try:
        c = int(code, 10)
    except ValueError:
        return None
    colors = [
        "#000000",
        "#800000",
        "#008000",
        "#808000",
        "#000080",
        "#800080",
        "#008080",
        "#c0c0c0",
    ]
    bright = [
        "#808080",
        "#ff0000",
        "#00ff00",
        "#ffff00",
        "#0000ff",
        "#ff00ff",
        "#00ffff",
        "#ffffff",
    ]
    if 30 <= c <= 37:
        return colors[c - 30]
    if 90 <= c <= 97:
        return bright[c - 90]
    if 40 <= c <= 47:
        return colors[c - 40]
    if 100 <= c <= 107:
        return bright[c - 100]
    return None


def rgb_to_hex(r: str, g: str, b: str):
    try:
        values = [int(r), int(g), int(b)]
    except ValueError:
        return None
    if any(v < 0 or v > 255 for v in values):
        return None
    return "#" + "".join(f"{v:02x}" for v in values)


def current_style(state: Dict[str, Any]) -> str:
    parts: List[str] = []
    if state["fg"]:
        parts.append(f"color:{state['fg']}")
    if state["bg"]:
        parts.append(f"background-color:{state['bg']}")
    if state["bold"]:
        parts.append("font-weight:bold")
    return ";".join(parts)


def ensure_line(state: Dict[str, Any], row: int) -> None:
    while len(state["lines"]) <= row:
        state["lines"].append([])


def set_cursor(state: Dict[str, Any], row: int, col: int) -> None:
    state["row"] = max(0, row)
    state["col"] = max(0, col)
    ensure_line(state, state["row"])


def apply_sgr(state: Dict[str, Any], code_str: str) -> None:
    codes = ["0"] if code_str == "" else [c for c in code_str.split(";") if c != ""]
    i = 0
    while i < len(codes):
        code_num = codes[i]
        if code_num == "?25":
            i += 1
            continue

        num = int(code_num) if code_num.isdigit() else None
        if num == 0:
            state["fg"] = None
            state["bg"] = None
            state["bold"] = False
        elif num == 1:
            state["bold"] = True
        elif num == 22:
            state["bold"] = False
        elif num == 39:
            state["fg"] = None
        elif num == 49:
            state["bg"] = None
        elif num == 38 and i + 1 < len(codes) and codes[i + 1] == "5":
            state["fg"] = ansi256_to_hex(codes[i + 2]) if i + 2 < len(codes) else None
            i += 2
        elif num == 48 and i + 1 < len(codes) and codes[i + 1] == "5":
            state["bg"] = ansi256_to_hex(codes[i + 2]) if i + 2 < len(codes) else None
            i += 2
        elif num == 38 and i + 3 < len(codes) and codes[i + 1] == "2":
            state["fg"] = rgb_to_hex(codes[i + 2], codes[i + 3], codes[i + 4]) if i + 4 < len(codes) else None
            i += 4
        elif num == 48 and i + 3 < len(codes) and codes[i + 1] == "2":
            state["bg"] = rgb_to_hex(codes[i + 2], codes[i + 3], codes[i + 4]) if i + 4 < len(codes) else None
            i += 4
        elif num is not None and ((30 <= num <= 37) or (90 <= num <= 97)):
            state["fg"] = basic_color(str(num))
        elif num is not None and ((40 <= num <= 47) or (100 <= num <= 107)):
            state["bg"] = basic_color(str(num))
        i += 1


def apply_csi(state: Dict[str, Any], params: str, code: str) -> None:
    cleaned = re.sub(r"\?", "", params)
    parts = [] if cleaned == "" else [p for p in cleaned.split(";") if p != ""]
    first = int(parts[0]) if parts and parts[0].isdigit() else None
    mode = parts[0] if parts else ""
    is_private = "?" in params

    if code == "m":
        apply_sgr(state, cleaned)
        return
    if code == "d":
        set_cursor(state, max(0, (first or 1) - 1), state["col"])
        return
    if code == "a":
        set_cursor(state, state["row"], state["col"] + (first or 1))
        return
    if code == "e":
        set_cursor(state, state["row"] + (first or 1), state["col"])
        return
    if code == "`":
        set_cursor(state, state["row"], max(0, (first or 1) - 1))
        return

    if code in ("h", "l"):
        if mode == "1049":
            if code == "h":
                state["lines"] = [[]]
                set_cursor(state, 0, 0)
                state["ignoreClearsAfterAltExit"] = False
            else:
                set_cursor(state, 0, 0)
                state["ignoreClearsAfterAltExit"] = True
        return

    if code == "s":
        state["savedRow"] = state["row"]
        state["savedCol"] = state["col"]
        return

    if code == "u":
        set_cursor(state, state.get("savedRow", 0), state.get("savedCol", 0))
        return

    if code in ("h", "l") and is_private:
        return

    if code == "A":
        set_cursor(state, state["row"] - (first or 1), state["col"])
    elif code == "B":
        set_cursor(state, state["row"] + (first or 1), state["col"])
    elif code == "C":
        set_cursor(state, state["row"], state["col"] + (first or 1))
    elif code == "D":
        set_cursor(state, state["row"], max(0, state["col"] - (first or 1)))
    elif code == "G":
        set_cursor(state, state["row"], max(0, (first or 1) - 1))
    elif code in ("H", "f"):
        row_val = first or 1
        col_val = int(parts[1]) if len(parts) > 1 and parts[1].isdigit() else 1
        set_cursor(state, row_val - 1, max(0, col_val - 1))
    elif code == "E":
        set_cursor(state, state["row"] + (first or 1), 0)
    elif code == "F":
        set_cursor(state, max(0, state["row"] - (first or 1)), 0)
    elif code == "K":
        ensure_line(state, state["row"])
        line = state["lines"][state["row"]]
        start = state["col"]
        for i in range(start, len(line)):
            line[i] = {"ch": " ", "style": ""}
    elif code == "J":
        ensure_line(state, state["row"])
        mode_num = 0 if first is None else first
        if state["ignoreClearsAfterAltExit"]:
            return
        if mode_num == 2:
            state["lines"] = [[]]
            set_cursor(state, 0, 0)
        else:
            for r in range(state["row"], len(state["lines"])):
                line = state["lines"][r]
                start = state["col"] if r == state["row"] else 0
                for i in range(start, len(line)):
                    line[i] = {"ch": " ", "style": ""}
    elif code == "r":
        set_cursor(state, 0, 0)
    elif code == "t":
        return


def write_char(state: Dict[str, Any], ch: str) -> None:
    ensure_line(state, state["row"])
    line = state["lines"][state["row"]]
    while len(line) <= state["col"]:
        line.append({"ch": " ", "style": ""})
    line[state["col"]] = {"ch": ch, "style": current_style(state)}
    state["col"] += 1


def append_text(state: Dict[str, Any], text: str) -> None:
    for ch in text:
        if ch == "\n":
            set_cursor(state, state["row"] + 1, 0)
        elif ch == "\r":
            set_cursor(state, state["row"], 0)
        elif ch == "\b":
            set_cursor(state, state["row"], max(0, state["col"] - 1))
        elif ch == "\t":
            next_stop = ((state["col"] // 8) + 1) * 8
            set_cursor(state, state["row"], next_stop)
        else:
            write_char(state, ch)


def parse_ansi(state: Dict[str, Any], text: str) -> None:
    normalized = text.replace("\r\n", "\n").replace("\r", "\n")
    index = 0
    while index < len(normalized):
        esc_index = normalized.find("\x1b", index)
        chunk = normalized[index:] if esc_index == -1 else normalized[index:esc_index]
        append_text(state, chunk)

        if esc_index == -1:
            break
        slice_text = normalized[esc_index:]
        csi_match = re.match(r"^\x1b\[([0-9?;]*)([A-Za-z])", slice_text)
        if csi_match:
            apply_csi(state, csi_match.group(1), csi_match.group(2))
            index = esc_index + len(csi_match.group(0))
            continue
        esc_move = re.match(r"^\x1b([DEM])", slice_text)
        if esc_move:
            code = esc_move.group(1)
            if code == "D":
                set_cursor(state, state["row"] + 1, state["col"])
            elif code == "E":
                set_cursor(state, state["row"] + 1, 0)
            elif code == "M":
                set_cursor(state, max(0, state["row"] - 1), state["col"])
            index = esc_index + len(esc_move.group(0))
            continue
        simple_esc = re.match(r"^\x1b[\(\)][A-Za-z0-9]", slice_text)
        if simple_esc:
            index = esc_index + len(simple_esc.group(0))
            continue
        one_char_esc = re.match(r"^\x1b[][><=]", slice_text)
        if one_char_esc:
            index = esc_index + len(one_char_esc.group(0))
            continue
        index = esc_index + 1


def lines_to_html(lines: List[List[Dict[str, str]]]) -> str:
    def render_line(line: List[Dict[str, str]]) -> str:
        if not line:
            return "&nbsp;"
        html_parts: List[str] = []
        open_style = ""
        for cell in line:
            cell = cell or {"ch": " ", "style": ""}
            safe_char = "&nbsp;" if cell["ch"] == " " else escape_html(cell["ch"])
            if cell["style"] != open_style:
                if open_style:
                    html_parts.append("</span>")
                if cell["style"]:
                    html_parts.append(f'<span style="{cell["style"]}">')
                open_style = cell["style"]
            html_parts.append(safe_char)
        if open_style:
            html_parts.append("</span>")
        return "".join(html_parts)

    return "<br/>".join(render_line(line) for line in lines)


def ansi_to_html(raw_text: str) -> str:
    state = create_state()
    parse_ansi(state, raw_text)
    if len(state["lines"]) > 1 and state["lines"][1]:
        first_cell = state["lines"][1][0]
        if first_cell.get("ch") == ">":
            state["lines"][1][0] = {"ch": " ", "style": first_cell.get("style", "")}
    return lines_to_html(state["lines"])


def parse_args():
    parser = argparse.ArgumentParser(description="Wrap a command and convert ANSI output to HTML.")
    parser.add_argument("--width", type=int, required=True, help="Pseudo-terminal width (columns).")
    parser.add_argument("--height", type=int, required=True, help="Pseudo-terminal height (rows).")
    parser.add_argument("--timeout", type=float, required=True, help="Timeout in seconds.")
    parser.add_argument("--raw", type=int, default=0, help="Return raw command output when set to 1.")
    parser.add_argument("cmd", nargs=argparse.REMAINDER, help="Command to run after '--'.")
    args = parser.parse_args()
    command = args.cmd
    if command and command[0] == "--":
        command = command[1:]
    if not command:
        parser.error("No command specified. Usage: wrapCommand --width=80 --height=40 --timeout=3 -- cmd")
    return args.width, args.height, args.timeout, bool(args.raw), command


def set_winsize(fd: int, rows: int, cols: int) -> None:
    packed = struct.pack("HHHH", rows, cols, 0, 0)
    if hasattr(termios, "TIOCSWINSZ"):
        fcntl.ioctl(fd, termios.TIOCSWINSZ, packed)


def run_command(cols: int, rows: int, timeout_sec: float, command: List[str]) -> str:
    master_fd, slave_fd = pty.openpty()
    try:
        set_winsize(slave_fd, rows, cols)
        proc = subprocess.Popen(
            command,
            stdin=slave_fd,
            stdout=slave_fd,
            stderr=slave_fd,
            close_fds=True,
        )
    finally:
        os.close(slave_fd)

    output = bytearray()
    deadline = time.time() + timeout_sec
    killed = False

    while True:
        if not killed and time.time() >= deadline and proc.poll() is None:
            os.kill(proc.pid, signal.SIGKILL)
            killed = True

        rlist, _, _ = select.select([master_fd], [], [], 0.1)
        if rlist:
            try:
                chunk = os.read(master_fd, 4096)
            except OSError:
                break
            if chunk:
                output.extend(chunk)
                continue
            break

        if proc.poll() is not None:
            drain, _, _ = select.select([master_fd], [], [], 0)
            if not drain:
                break

    try:
        proc.wait(timeout=0)
    except subprocess.TimeoutExpired:
        pass
    finally:
        os.close(master_fd)

    return output.decode(errors="replace")


def main():
    width, height, timeout_sec, raw_output, command = parse_args()
    raw_text = run_command(width, height, timeout_sec, command)
    if raw_output:
        sys.stdout.write(raw_text)
    else:
        html = ansi_to_html(raw_text)
        print(html)


if __name__ == "__main__":
    main()
